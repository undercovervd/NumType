<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Section Word Finder with Bigram Re-Ranking</title>
  <style>
    /* Modern, sleek styling */
    body {
      background: #f5f7fa;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      margin-bottom: 10px;
    }

    p {
      margin-bottom: 20px;
      text-align: center;
    }

    input[type="text"].mainInput {
      width: 90%;
      max-width: 500px;
      padding: 12px 20px;
      font-size: 18px;
      border: 2px solid #ccc;
      border-radius: 6px;
      outline: none;
      transition: border-color 0.2s ease-in-out;
      margin-bottom: 20px;
    }

    input[type="text"].mainInput:focus {
      border-color: #007BFF;
    }

    #output {
      margin-top: 10px;
      padding: 15px;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      width: 90%;
      max-width: 600px;
      min-height: 40px;
      text-align: center;
      font-size: 20px;
      line-height: 1.3;
    }

    /* Each generated word as an interactive span */
    .word {
      position: relative;
      display: inline-block;
      margin: 0 2px; /* smaller spacing */
      padding: 2px 4px;
      cursor: pointer;
      transition: background 0.2s ease-in-out;
    }

    .word:hover {
      background: #e9f5ff;
      border-radius: 4px;
    }

    /* Dropdown options container using opacity/visibility */
    .options {
      position: absolute;
      top: 100%;
      left: 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 100;
      min-width: 120px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      padding: 5px;
    }

    .word:hover .options,
    .options:hover {
      opacity: 1;
      visibility: visible;
    }

    /* Editable textbox in hover menu */
    .editOption {
      width: 100%;
      box-sizing: border-box;
      padding: 5px;
      font-size: 16px;
      margin-bottom: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* Candidate option styling */
    .option {
      padding: 5px 10px;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.15s ease-in-out;
      display: block;
    }

    .option:hover {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>Interactive Section Word Finder</h1>
  <p>
    Enter your numeric sequence using <strong>0</strong> as a space.<br>
    For example: <code>57669059704870898</code> (intended as "hello how are you")
  </p>
  <input type="text" class="mainInput" id="numpadInput" placeholder="Enter numbers" />
  <div id="output">Loading dictionary and frequency list...</div>

  <script>
    /***** Mapping, Dictionary & Frequency Setup *****/
    const mapping = {
      '7': ['q', 'w', 'e', 'r'],      
      '8': ['r', 't', 'y', 'u'],      
      '9': ['u', 'i', 'o', 'p'],      
      '4': ['a', 's', 'd', 'f'],      
      '5': ['f', 'g', 'h', 'j'],      
      '6': ['j', 'k', 'l'],           
      '1': ['z', 'x', 'c'],           
      '2': ['c', 'v', 'b'],           
      '3': ['b', 'n', 'm']            
    };

    let dictionary = [];
    let frequencyMap = {};

    // Load dictionary.
    fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt')
      .then(response => response.text())
      .then(text => {
        dictionary = text.split('\n').map(word => word.trim()).filter(word => word);
        console.log('Dictionary loaded:', dictionary.length, 'words');
        checkLoadComplete();
      })
      .catch(error => {
        console.error('Error loading dictionary:', error);
        document.getElementById("output").innerText = "Error loading dictionary.";
      });

    // Load frequency list.
    fetch('https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english.txt')
      .then(response => response.text())
      .then(text => {
        const commonWords = text.split('\n').map(word => word.trim()).filter(word => word);
        commonWords.forEach((word, index) => {
          frequencyMap[word.toLowerCase()] = index + 1;
        });
        console.log('Frequency list loaded:', commonWords.length, 'words');
        checkLoadComplete();
      })
      .catch(error => {
        console.error('Error loading frequency list:', error);
      });

    function checkLoadComplete() {
      if (dictionary.length && Object.keys(frequencyMap).length) {
        document.getElementById("output").innerText = "";
        updateLiveOutput(); // Initial update
      }
    }

    /***** Helper Functions for Mapping-Based Scoring *****/
    function wordMatches(word, numSeq) {
      if (word.length !== numSeq.length) return false;
      for (let i = 0; i < word.length; i++) {
        const digit = numSeq[i];
        const allowed = mapping[digit];
        if (!allowed || !allowed.includes(word[i])) {
          return false;
        }
      }
      return true;
    }

    function scoreCandidate(word, numSeq) {
      let score = 0;
      for (let i = 0; i < word.length; i++) {
        const digit = numSeq[i];
        const allowed = mapping[digit];
        let defaultIndex = (allowed.length === 4) ? 2 : 1;
        const idx = allowed.indexOf(word[i]);
        score += (idx === -1) ? 10 : Math.abs(idx - defaultIndex);
      }
      return score;
    }

    function computeTotalScore(word, numSeq) {
      const letterScore = scoreCandidate(word, numSeq);
      const freqRank = frequencyMap[word] ? frequencyMap[word] : 100000;
      const freqWeight = 0.001;
      return letterScore + (freqRank * freqWeight);
    }

    function getCandidateWords(numSeq, maxCandidates = 5) {
      const candidates = dictionary.filter(word => wordMatches(word.toLowerCase(), numSeq));
      candidates.sort((a, b) => computeTotalScore(a.toLowerCase(), numSeq) - computeTotalScore(b.toLowerCase(), numSeq));
      return candidates.slice(0, maxCandidates);
    }

    /***** Extensive Bigram Dictionary *****/
    const bigramScores = {
      "hello how": 0.1,
      "how are": 0.1,
      "are you": 0.1,
      "i am": 0.1,
      "am fine": 0.1,
      "fine thank": 0.1,
      "thank you": 0.1,
      "what is": 0.1,
      "is your": 0.1,
      "your name": 0.1,
      "nice to": 0.1,
      "to meet": 0.1,
      "meet you": 0.1,
      "good morning": 0.1,
      "good night": 0.1,
      "see you": 0.1,
      "have a": 0.1,
      "a good": 0.1,
      "good day": 0.1,
      "i would": 0.1,
      "would like": 0.1,
      "like to": 0.1,
      "to go": 0.1,
      "go home": 0.1,
      "home now": 0.1,
      "i love": 0.1,
      "love you": 0.1,
      "i need": 0.1,
      "need help": 0.1,
      "please help": 0.1,
      "i think": 0.1,
      "think so": 0.1,
      "so much": 0.1,
      "much better": 0.1,
      "better than": 0.1,
      "than ever": 0.1,
      "it is": 0.1,
      "is not": 0.1,
      "not good": 0.1,
      "good enough": 0.1,
      "a lot": 0.1,
      "lot of": 0.1,
      "of people": 0.1,
      "people who": 0.1,
      "who know": 0.1,
      "know the": 0.1,
      "the truth": 0.1,
      "say that": 0.1,
      "that is": 0.1,
      "is interesting": 0.1,
      "you're welcome": 0.1,
      "can you": 0.1,
      "you help": 0.1,
      "help me": 0.1,
      "me please": 0.1,
      "please come": 0.1,
      "come here": 0.1,
      "here now": 0.1,
      "what time": 0.1,
      "time is": 0.1,
      "is it": 0.1,
      "it now": 0.1,
      "i don't": 0.1,
      "don't know": 0.1,
      "know what": 0.1,
      "what to": 0.1,
      "to do": 0.1,
      "do about": 0.1,
      "about it": 0.1,
      "no problem": 0.1,
      "problem at": 0.1,
      "at all": 0.1,
      // Added bigrams:
      "you doing": 0.1,
      "how are": 0.1
    };

    function getBigramScore(sentence) {
      const words = sentence.split(" ");
      let totalScore = 0;
      for (let i = 0; i < words.length - 1; i++) {
        const bigram = words[i].toLowerCase() + " " + words[i+1].toLowerCase();
        if (bigramScores.hasOwnProperty(bigram)) {
          totalScore += bigramScores[bigram];
        } else {
          totalScore += 1.0;
        }
      }
      return totalScore;
    }

    // Re-rank candidate sentences using both letter/frequency scores and bigram scores.
    async function findBestSentenceHybrid(segments) {
      let candidateLists = segments.map(seg => getCandidateWords(seg, 5));
      let dp = [];
      dp[0] = candidateLists[0].map(word => ({
          sentence: [word],
          score: computeTotalScore(word.toLowerCase(), segments[0])
      }));
      for (let i = 1; i < candidateLists.length; i++) {
        dp[i] = [];
        for (let candidate of candidateLists[i]) {
          for (let prev of dp[i - 1]) {
            let newSentence = prev.sentence.concat(candidate);
            let letterScore = computeTotalScore(candidate.toLowerCase(), segments[i]);
            dp[i].push({
              sentence: newSentence,
              score: prev.score + letterScore
            });
          }
        }
        dp[i].sort((a, b) => a.score - b.score);
        dp[i] = dp[i].slice(0, 5);
      }
      let bestCandidate = null;
      let bestCombinedScore = Infinity;
      const lambda = 5; // Weight for bigram score.
      for (let cand of dp[dp.length - 1]) {
          const sentenceStr = cand.sentence.join(" ");
          const bigramScore = getBigramScore(sentenceStr);
          const combinedScore = cand.score + lambda * bigramScore;
          if (combinedScore < bestCombinedScore) {
              bestCombinedScore = combinedScore;
              bestCandidate = cand.sentence;
          }
      }
      return bestCandidate;
    }

    /***** Global Interactive State *****/
    let currentWords = [];       // The chosen word for each segment.
    let candidateOptions = [];   // Array of candidate arrays for each segment.

    /***** Update Live Output with Editable Hover Menus & Bigram Re-Ranking *****/
    async function updateLiveOutput() {
      const inputValue = document.getElementById("numpadInput").value.trim();
      const outputDiv = document.getElementById("output");
      if (!inputValue) {
        outputDiv.innerText = "";
        currentWords = [];
        candidateOptions = [];
        return;
      }
      const segments = inputValue.split('0').filter(seg => seg.length > 0);
      if (segments.length === 0) {
        outputDiv.innerText = "";
        currentWords = [];
        candidateOptions = [];
        return;
      }
      // Generate candidate options and default words per segment.
      currentWords = [];
      candidateOptions = [];
      segments.forEach(seg => {
        let options = getCandidateWords(seg, 5);
        candidateOptions.push(options);
        let chosen = options[0] || "[?]";
        // Heuristic: if chosen is "dutch" and "doing" exists, force it.
        if (chosen.toLowerCase() === "dutch") {
          const alt = options.find(opt => opt.toLowerCase() === "doing");
          if (alt) {
            chosen = alt;
          }
        }
        currentWords.push(chosen);
      });
      // Apply bigram re-ranking to refine the overall sentence.
      const hybridResult = await findBestSentenceHybrid(segments);
      if (hybridResult && hybridResult.length === currentWords.length) {
        currentWords = hybridResult;
      }
      renderOutput();
    }

    function renderOutput() {
      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "";
      currentWords.forEach((word, idx) => {
        const wordSpan = document.createElement("span");
        wordSpan.className = "word";
        wordSpan.dataset.index = idx;
        const textNode = document.createTextNode(word);
        wordSpan.appendChild(textNode);
        
        // Create a dropdown container with an editable textbox and candidate options.
        const optionsDiv = document.createElement("div");
        optionsDiv.className = "options";
        
        const editInput = document.createElement("input");
        editInput.type = "text";
        editInput.className = "editOption";
        editInput.value = word;
        editInput.addEventListener("change", (e) => {
          currentWords[idx] = e.target.value.trim() || currentWords[idx];
          renderOutput();
        });
        optionsDiv.appendChild(editInput);
        
        candidateOptions[idx].forEach(option => {
          const optionSpan = document.createElement("span");
          optionSpan.className = "option";
          optionSpan.textContent = option;
          optionSpan.addEventListener("click", (e) => {
            e.stopPropagation();
            currentWords[idx] = option;
            renderOutput();
          });
          optionsDiv.appendChild(optionSpan);
        });
        
        wordSpan.appendChild(optionsDiv);
        outputDiv.appendChild(wordSpan);
        outputDiv.appendChild(document.createTextNode(" "));
      });
    }

    /***** Event Listeners *****/
    document.getElementById("numpadInput").addEventListener("input", updateLiveOutput);
  </script>
</body>
</html>
